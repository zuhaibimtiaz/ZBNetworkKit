// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name ZBNetworkKitFramework
import Combine
import CommonCrypto
import Foundation
import MobileCoreServices
import OSLog
import Swift
import SwiftUI
import UniformTypeIdentifiers
@_exported import ZBNetworkKitFramework
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public enum Log {
  public enum Level {
    case error
    case warning
    case info
    public static func == (a: ZBNetworkKitFramework.Log.Level, b: ZBNetworkKitFramework.Log.Level) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Context {
  }
  public static func info(_ message: Swift.String, shouldLogContext: Swift.Bool = true, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line)
  public static func warning(_ message: Swift.String, shouldLogContext: Swift.Bool = true, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line)
  public static func error(_ message: Swift.String, shouldLogContext: Swift.Bool = true, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line)
}
public enum ZBAPIError : Swift.Error, Swift.Equatable {
  public struct ZBErrorModel : Swift.Equatable {
    public static func == (a: ZBNetworkKitFramework.ZBAPIError.ZBErrorModel, b: ZBNetworkKitFramework.ZBAPIError.ZBErrorModel) -> Swift.Bool
  }
  case networkError(Swift.String)
  case unauthorized
  case invalidRequest
  case tokenRefreshFailed
  case sslPinningFailed
  case decodingError(Swift.String)
  case timeout
  case cancelled
  case custom(model: ZBNetworkKitFramework.ZBAPIError.ZBErrorModel)
  public var localizedDescription: Swift.String {
    get
  }
  public static func == (a: ZBNetworkKitFramework.ZBAPIError, b: ZBNetworkKitFramework.ZBAPIError) -> Swift.Bool
}
public protocol ZBEndpointProvider {
  var scheme: Swift.String { get }
  var baseURL: Swift.String { get }
  var path: Swift.String { get }
  var method: ZBNetworkKitFramework.RequestMethod { get }
  var queryItems: [Foundation.URLQueryItem]? { get }
  var headers: [Swift.String : Swift.String]? { get }
  var parameters: [Swift.String : Any]? { get }
  var encodedParams: (any Swift.Encodable)? { get }
  var multipart: ZBNetworkKitFramework.ZBMultipartRequest? { get }
  var uploadData: Foundation.Data? { get }
  var accessTokenRequired: Swift.Bool { get }
  var timeoutInterval: Foundation.TimeInterval? { get }
  var interceptors: [any ZBNetworkKitFramework.ZBInterceptor] { get }
  func buildURLRequest() throws -> Foundation.URLRequest
}
public enum RequestMethod : Swift.String {
  case DELETE, GET, PATCH, POST, PUT
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension ZBNetworkKitFramework.ZBEndpointProvider {
  public var scheme: Swift.String {
    get
  }
  public var baseURL: Swift.String {
    get
  }
  public var queryItems: [Foundation.URLQueryItem]? {
    get
  }
  public var headers: [Swift.String : Swift.String]? {
    get
  }
  public var parameters: [Swift.String : Any]? {
    get
  }
  public var encodedParams: (any Swift.Encodable)? {
    get
  }
  public var multipart: ZBNetworkKitFramework.ZBMultipartRequest? {
    get
  }
  public var uploadData: Foundation.Data? {
    get
  }
  public var accessTokenRequired: Swift.Bool {
    get
  }
  public var timeoutInterval: Foundation.TimeInterval? {
    get
  }
  public var interceptors: [any ZBNetworkKitFramework.ZBInterceptor] {
    get
  }
  public func buildURLRequest() throws -> Foundation.URLRequest
}
final public class ZBHttpClient : ZBNetworkKitFramework.ZBNetworkClientProtocol {
  public init()
  final public func addInterceptor(_ interceptor: any ZBNetworkKitFramework.ZBInterceptor)
  final public func asyncRequest<T>(endpoint: any ZBNetworkKitFramework.ZBEndpointProvider, responseModel: T.Type) async throws -> T where T : Swift.Decodable
  final public func asyncUpload<T>(endpoint: any ZBNetworkKitFramework.ZBEndpointProvider, responseModel: T.Type) async throws -> T where T : Swift.Decodable
  final public func downloadFile(endpoint: any ZBNetworkKitFramework.ZBEndpointProvider) async throws -> Foundation.Data
  @objc deinit
}
public struct ZBMultipartRequest {
}
public protocol ZBNetworkClientProtocol {
  func asyncRequest<T>(endpoint: any ZBNetworkKitFramework.ZBEndpointProvider, responseModel: T.Type) async throws -> T where T : Swift.Decodable
  func asyncUpload<T>(endpoint: any ZBNetworkKitFramework.ZBEndpointProvider, responseModel: T.Type) async throws -> T where T : Swift.Decodable
  func downloadFile(endpoint: any ZBNetworkKitFramework.ZBEndpointProvider) async throws -> Foundation.Data
  func addInterceptor(_ interceptor: any ZBNetworkKitFramework.ZBInterceptor)
}
public protocol ZBInterceptor {
  func onRequest(_ request: inout Foundation.URLRequest)
  func onResponse(_ data: Foundation.Data?, _ response: Foundation.URLResponse?, _ error: (any Swift.Error)?)
}
extension ZBNetworkKitFramework.ZBInterceptor {
  public func onRequest(_ request: inout Foundation.URLRequest)
  public func onResponse(_ data: Foundation.Data?, _ response: Foundation.URLResponse?, _ error: (any Swift.Error)?)
}
public struct ZBLoggingInterceptor : ZBNetworkKitFramework.ZBInterceptor {
  public func onRequest(_ request: inout Foundation.URLRequest)
  public func onResponse(_ data: Foundation.Data?, _ response: Foundation.URLResponse?, _ error: (any Swift.Error)?)
}
public enum ZBNetworkKit {
  public static func configure(scheme: Swift.String = "https", baseURL: Swift.String, publicKeyHash: Swift.String? = nil, refreshTokenEndpoint: (any ZBNetworkKitFramework.ZBEndpointProvider)? = nil, defaultHeaders: [Swift.String : Swift.String]?, globalInterceptors: [any ZBNetworkKitFramework.ZBInterceptor]?, refreshTokenRetryCount: Swift.Int = 0, defaultTimeout: Foundation.TimeInterval = 60, resourceTimeout: Foundation.TimeInterval = 90, isLogging: Swift.Bool = true)
  public static func setToken(access: Swift.String, refresh: Swift.String? = nil)
  public static func clearToken()
}
@propertyWrapper public struct ApiRequest<T> : SwiftUICore.DynamicProperty where T : Swift.Decodable {
  public var wrappedValue: T? {
    get
  }
  public var projectedValue: ZBNetworkKitFramework.ApiRequest<T> {
    get
  }
  public init(endpoint: some ZBEndpointProvider, client: any ZBNetworkKitFramework.ZBNetworkClientProtocol = ZBHttpClient())
  public func fetch() async
  public var isLoading: Swift.Bool {
    get
  }
  public var error: ZBNetworkKitFramework.ZBAPIError? {
    get
  }
  public func publisher() -> Combine.AnyPublisher<Swift.Result<T, ZBNetworkKitFramework.ZBAPIError>, Swift.Never>
}
@_hasMissingDesignatedInitializers public class ZBRefreshTokenManager {
  public static let shared: ZBNetworkKitFramework.ZBRefreshTokenManager
  public func refreshToken() async throws
  @objc deinit
}
extension ZBNetworkKitFramework.Log.Level : Swift.Equatable {}
extension ZBNetworkKitFramework.Log.Level : Swift.Hashable {}
extension ZBNetworkKitFramework.RequestMethod : Swift.Equatable {}
extension ZBNetworkKitFramework.RequestMethod : Swift.Hashable {}
extension ZBNetworkKitFramework.RequestMethod : Swift.RawRepresentable {}
